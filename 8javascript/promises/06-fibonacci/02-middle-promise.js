// =============================================================================
// РЕКУРСИЯ + ПРОМИСЫ (БЫСТРЫЙ СПОСОБ)
// =============================================================================
// Map(), выполняющий роль кеша (хранилище результатов)
const cache = new Map();


// =============================================================================
// Рекурсивная функция (асинхронная, на промисах)
// =============================================================================
const fib = (n) => {
  // 1. Функция возвращает проис
  return new Promise((resolve) => {
    // 1. Простой случай
    // 1.1. Если "n" равно "0" или "1"
    if (n === 0 || n === 1) {
      // 1.2. Выполнить промис, передав значение
      resolve(n);
      // 1.3. Остановить выполнение функции
      return;
    }
    
    // 2. Сложный случай
    // 2.1. Если результат для этого числа уже есть, использовать его
    if (cache.has(n)) resolve(cache.get(n));
    
    // 2.2. setImmediate(), чтобы код выполнялся на фазе "Check"
    setImmediate(() => {
      // 2.3. Сначала вызвать первую функцию "fib(n - 1)",
      // .... получить результат и затем вызвать "fib(n - 2)"
      fib(n - 1).then((res1) => fib(n - 2).then((res2) => {
        // 2.4. Полученные результаты суммировать
        const sum = res1 + res2;
        // 2.5. Сумму записывать в "кеш"
        cache.set(n, sum);
        // 2.6. Выполнить промис, передав сумму результатов
        resolve(sum);
      }))
    })
  })
}



// =============================================================================
// Вызов функции
// =============================================================================
fib(5).then(console.log)
fib(40).then(console.log)

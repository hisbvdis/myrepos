let counter = 0;
const max = 1e9;
const startTime = Date.now();



// ===========================================================================
// 1. НУЖНО ВЫПОЛНИТЬ ТЯЖЕЛЫЕ ВЫЧИСЛЕНИЯ
// ---------------------------------------------------------------------------
// Проблема — браузер "зависает", пока идут вычисления
// ===========================================================================
const func1 = () => {
  // 1.1. Тяжёлые вычисления, во время которых браузер "зависает"
  do {
    counter++;
  } while (counter !== max)

  // 1.2. Вывести длительность выполнения
  console.log("Func 1 — " + (Date.now() - startTime) + 'ms');
}



// ===========================================================================
// 2. РЕШЕНИЕ
// ---------------------------------------------------------------------------
// Принцип — разбить тяжёлое вычисление на части и запускать с помощью таймера,
// делая их отдельными "мАкрозадачами", позволяя не "зависать" браузеру
// ===========================================================================
const func2 = () => {
  console.log("Step");

  // 2.1. Сделать 1/10 часть тяжёлой работы
  do {
    counter++;
  } while (counter % (max / 10) !== 0);
  
  // 2.2. Если работа завершена — вывести длительность выполнения
  if (counter >= max) {
    console.log("Func 2 — " + (Date.now() - startTime) + 'ms');
  }
  
  // 2.3. Иначе — снова вызвать функцию, но внутри таймера,
  // .... а значит в новой "мАкрозадаче", позволяя не "зависать" браузеру
  else {
    setTimeout(func2);
  }
}



// ===========================================================================
// 3. РЕШЕНИЕ — ОПТИМИЗИРОВАННОЕ
// ---------------------------------------------------------------------------
// — Суть оптимизации — запланировать новый вызов до выполнения вычислений,
//   чтобы избежать задержки 4ms перед запуском "setTimeout()"
// — Разница хорошо видна при большом количестве вызовов функции (тысячи)
// ===========================================================================
const func3 = () => {
  console.log("Step");
  
  // 3.1. Заранее определить, нужно ли будет ещё считать
  // .... Если это не последний счёт, снова вызвать функцию, но внутри таймера,
  // .... а значит в новой "мАкрозадаче", позволяя не "зависать" браузеру
  if ((counter + (max / 10)) < max) {
    setTimeout(func3);
  }
  
  // 3.2. Сделать 1/10 часть тяжёлой работы
  do {
    counter++;
  } while (counter % (max / 10) !== 0);

  // 3.3. Если работа завершена — вывести длительность выполнения
  if (counter >= max) {
    console.log("Func 3 — " + (Date.now() - startTime) + 'ms');
  }
}



// ===========================================================================
// Запуск разных примеров
// ===========================================================================
// func1();
// func2();
// func3();

let counter = 0;
const max = 1e6;
const progressElem = document.querySelector("progress");
progressElem.max = max;



// ===========================================================================
// 1. НУЖНО ВЫПОЛНИТЬ ТЯЖЕЛЫЕ ВЫЧИСЛЕНИЯ
// ---------------------------------------------------------------------------
// Проблема — индикатор прогресса обновляется только после вычислений
// ===========================================================================
const func1 = () => {
  console.log("Step");
  
  do {
    counter++;
    // 1.1. Команда "progressElem.value = counter" — это рендеринг в браузере
    // .... значения переменной "counter"
    // 1.2. А в "Event Loop" рендеринг в браузере выполняется между мАкрозадачами
    // .... после всех мИкрозадач
    // 1.3. Следовательно — обновление значения на странице произойдёт лишь
    // .... после полного завершения цикла "do-while", который входит в первую
    // .... мАкрозадачу "синхронный код"
    progressElem.value = counter;
  }
  while (counter !== max)
}



// ===========================================================================
// 2. РЕШЕНИЕ
// ---------------------------------------------------------------------------
// Принцип — разбить тяжёлое вычисление на части и запускать с помощью таймера,
// делая их отдельными "мАкрозадачами" и позволяя "рендерить" между ними
// ===========================================================================
const func2 = () => {
  console.log("Step");
  
  // 2.1. Сделать 1/10 часть тяжёлой работы
  do {
    counter++;
    progressElem.value = counter;
  } while (counter % (max / 10) !== 0);
  
  // 2.2. Если максимум не достигнут, снова вызвать функцию, но внутри таймера,
  // .... а значит в новой "мАкрозадаче", позволяя "рендерить" между ними
  if (counter < max) {
    setTimeout(func2);
  }
}



// ===========================================================================
// Запуск разных примеров
// ===========================================================================
// func1();
// func2()
